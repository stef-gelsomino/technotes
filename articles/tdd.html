<html>
<head>
    <meta charset="UTF-8">
    <title> Technische Softwareentwicklung Notizen </title>
    <link href='https://fonts.googleapis.com/css?family=Lora' rel='stylesheet'>
    <link href='https://fonts.googleapis.com/css?family=Lora:i' rel='stylesheet'>
    <link rel="stylesheet" type="text/css" href="../prism/prism_2.css">
    <link rel="stylesheet" type="text/css" href="../styles/style.css">
</head>
<body>
<script type="text/javascript" src="../prism/prism_2.js"></script>
<div id="header">
    <h1><a href="../index.html">Architektur und Entwicklung</a></h1>
    <nav>
        <a href="http.html"> HTTP </a> &nbsp;
        <a href="ansible.html"> Ansible </a> &nbsp;
        <a href="go.html"> Go </a> &nbsp;
        <a href="spring.html"> Spring </a> &nbsp;
        <a href="spring_data.html"> Spring Data </a> &nbsp;
        <a href="tdd.html"> TDD </a> &nbsp;
        <a href="python.html"> Python </a> &nbsp;
    </nav>
</div>
<div class="main">
    <article>
        <header>
            <h2>
                Test-Driven Development
            </h2>
        </header>

        <section>
            <h3>
                Einleitung
            </h3>
            <p>
                TDD ist eine Methodologie, die auf Testing konzentriert ist. Nach diese Methodologie, müssen der Business Code und seine Tests zusammen entwickelt werden.
                Nach diese Ansatz, ist es ein Anti-pattern um ein groß Modul ganz zu entwickeln und nur danach ausfinden, wie dieses Modul getestet werden soll.
                <br>
                Im Besonderen:
            <ul>
                <li>Man denkt nicht an Automatisierung von Tests (z.B. hat diese Methode einen einzige Zweck?)</li>
                <li>Man bekommt die Vorteile von Automatisierung nicht (z.B. Regressionstest während der Entwicklung)</li>
                <li>
                    Zeitsverwaltung im Project:
                    <ul>
                        <li>es wird immer wieder schweriger, das ganze Projekt zu testen</li>
                        <li>Wegen der Deadline (und auch aus dem Grund, dass Code auf jeden Fall "funktioniert") die Manager möchten keine Zeit am Ende für Teste verschwenden.</li>
                    </ul>
                </li>
                <li>Eine zu groß Arbeitsmenge am Ende des Projekts</li>
            </ul>
            </p>
            <p>
                Wichtige Vorteile sind:
            <ul>
                <li>gut Gleichgewicht von Testcode und Funktionalitätscode</li>
                <li>zuverlässige wiederholbarkeit von Tests (die wiederum leitet zu zuversichtlich Refaktorisierung)</li>
                <li>Design Prozess berücksichtigt Test up-front (d.h. Testable Design)</li>
            </ul>
            <img src="red_green.jpg" alt="Red-Green-refactor Diagram">
            Stichwörter:
            <ul>
                <li>xUnit Testing</li>
                <li>Class Under Test</li>
                <li>Method Under Test</li>
                <li>Test Fixture (Setup von Daten, die im Test verwendet werden)</li>
            </ul>
            Mythen (die falsch sind):
            <ul>
                <li>verdoppelte Coding-Effort</li>
                <li>
                    Alle Tests müssen bereits erledigt sein, vor die Funktionalitätscode geschrieben wird:
                    das ist einfach eine Fehlinterpretation von Test-First-Development! Man soll nur einfach den Red/Green/Refactor Zyklus folgen
                </li>
            </ul>
            Testing Frameworks (JVM Welt):
            <ul>
                <li>Mokckito: Mocking von Abhängigkeiten</li>
                <li>DBUnit: Fixtures von SQL Datenbanken</li>
                <li></li>
            </ul>
            H2 Datenbank:
            <ul>
                <li>relational Datenbank in Java</li>
                <li>in/out-of-process Ausführung (gut für Tests)</li>
                <li>das h2 Verzeichnis herunterladen und unzippen in /opt Ordner</li>
            </ul>
            </p>
        </section>

        <section>
            <h3>
                JUnit
            </h3>
            <p>Ein gutes Test besteht aus vier Schritte:</p>
            <ul>
                <li>
                    Setup: <br> man baut hier Daten als Fixtures z.B. Objekte vorbereiten, die als Abhängigkeiten zum Class-Under-Test verbunden werden
                </li>
                <li>
                    Execution: <br> in diesem Schritt ruft man das Method-Under-Test auf.
                    Aufgepasst: je nach dem Komplexität vom Test, kann man <i>one-test-per-class</i> oder <i>one-test-per-method</i> bauen.
                </li>
                <li>
                    Verification: <br> die Ergebnisse von der Ausführung werden überprüft. Sehr wichtig nicht nur <i>Output</i> zu checken
                    sondern auch mögliche Änderungen im Zustand von Objekte.
                </li>
                <li>
                    Teardown: <br> Kram entfernen, unlocken und sauber machen, die war im Setup vorbereitet.
                </li>
            </ul>
            <p>Glücklicherweise gibt es in JUnit (Package <b style="font-family:monospace">org.junit</b>) eingebaute Unterstütung für jede Schritt.</p>
            <p>
                Jede Test wird mit der @Test Annotation markiert. Was wir wollen als Setup-Schritt ausführen, wird in eine Methode sein, die
                mit @Before markiert wird. Analog wird unsere Teardown-Methode mit @After markiert. Die genannte Mothoden werden vor und nach jede
                Test-Methode ausgeführt werden. Falls wir brauchen eine globale Setup/Teardown (d.h. die ist einmalig vor/nach <i>alle</i> dem Test gelaufen)
                stehen die @BeforeClass und @AfterClass Annotationen uns zu Verfügung.
            </p>
            <p>
                Beim Verification gibt es eine reiche Auswahl von <i>"Assertion"</i> Mechanismen:
                Nämlich gibt es die statische Methoden in <b style="font-family:monospace">org.junit.Assert.*</b> und die
                <b style="font-family:monospace">HamcrestMatcherAssert</b> Methoden.
            </p>
            <p>Hamcrest ist eine Bibliotheke, die das regelmäßige JUnit Assert-Mechanismus erweitert. Manchmal (eigentlich oft) sind die Assertions von
            Hamcrest lesbarer als die JUnit, manchmal aber umgekehrt.</p>
            Ein paar Beispiele:
            <pre>
                <code class="language-java">
                    // JUnit (here looking better)
                    assertEquals("Brown", actualCustomer.gatName());

                    // Hamcrest
                    assertThat(actualCustomer.gatName(), equalTo("Brown"));
                </code>
            </pre>
            <pre>
                <code class="language-java">
                    // JUnit
                    assertTrue(actualCustomer.gatName().startsWith("B");

                    // Hamcrest (here looking better)
                    assertThat(actualCustomer.gatName(), startsWith("B"));
                </code>
            </pre>
            Nun schauen wir uns ein Beispiel von eine Test-Methode:
            <pre>
                <code class="language-java">
                    // test name format test_operationName_expectedResult

                    @Test
                    public void test_transform_success() {
                        String orderNumberFixture = UUID.randomUUID().toString();
                        OrderSummary result = target.transform(null);
                        assertNotNull(result);
                        assertEquals(orderNumberFixture, result.getOrderNumber());
                    }
                </code>
            </pre>

            Eine Test-Methode kann mit <b style="font-family:monospace">@Ignore</b> markiert werden, damit der Test-Runner läuft sie nicht.

            Außerdem, können wir unsere Test-Methode sagen, dass sie sollte eine Exception erwarten
            <pre>
                <code class="language-java">
                    @Test(expected = IllegalArgumentException.class)
                    public void test_transform_failure() {
                        target.transform(null);
                    }
                </code>
            </pre>
        </section>

        <section>
            <h3>
                Mockito
            </h3>
            <p>

            </p>
        </section>

        <section>
            <h3>
                Powermock
            </h3>
            <p>

            </p>
        </section>

        <section>
            <h3>
                Verwaltung von Fixture und Testing von Datenkomponenten
            </h3>
            <p>

            </p>
        </section>
    </article>
</div>
<div class="footer">
    <div id="fool">
        <h3><a target="_blank" href="https://www.linkedin.com/in/stefano-gelsomino-8b0b7913a/"><span>Site by</span> <span>Stefano Gelsomino</span> </a></h3>
    </div>
    <a id="follow" target="_blank" href="https://www.linkedin.com/in/stefano-gelsomino-8b0b7913a/">
        <img src="../img/linkedin.png"/>
    </a>
    <div id="foor">
        <h3>2017</h3>
    </div>
</div>
</body>
</html>
