<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>TD Development</title>
    <link rel="icon" href="../img/favicon.ico">
    <link href="https://fonts.googleapis.com/css?family=Orbitron" rel="stylesheet">
    <link href='https://fonts.googleapis.com/css?family=Lora' rel='stylesheet'>
    <link href='https://fonts.googleapis.com/css?family=Lora:i' rel='stylesheet'>
    <link rel="stylesheet" type="text/css" href="../prism/prism_2.css">
    <link rel="stylesheet" type="text/css" href="../styles/style.css">
</head>
<body>
<script type="text/javascript" src="../prism/prism_2.js"></script>
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script type="text/javascript" src="../scripts/mask.js"></script>
<div class="authorInfo">
    <img src="https://s.gravatar.com/avatar/eded46e11f38d45392e2c34926430fd2?s=80" alt="Author Pic" style="width:200px;height:170px;">
    <h3>von <i>Gabriele Falace</i></h3>
    <p>Computer-Ingenieur in Berlin</p>
</div>  
<div ID = "toc7">

<nav>

	        <a href="tdd.html#einLeit">Einleitung</a>
            <a href="tdd.html#junit">JUnit</a>
            <a href="tdd.html#mock">Mockito</a>
            <a href="tdd.html#power">Powermock</a>
            <a href="tdd.html#verWal">Verwaltung von Fixture und Testing von Datenkomponenten</a>
            <a href="tdd.html#oben7">Zurück nach oben</a>

</nav>

</div>    
<div id="header">
</div>
     <!-- DROP-DOWN-MENU -->
<div class="dropdown">
  <button onclick="myFunction()" class="dropbtn">Menu</button>
  <div id="myDropdown" class="dropdown-content">
    <a href="http.html">HTTP</a>
    <a href="ansible.html">Ansible</a>
    <a href="go.html">Go</a>
    <a href="spring.html">Spring Boot</a>  
    <a href="spring_data.html">Spring Data</a>
    <a href="spring_cloud.html">Spring Cloud</a> 
    <a href="python.html">Python</a> 
    <a href="jenkins.html">Jenkins</a>
    <a href="../index.html">Home</a>
  </div>
</div>   
    <!-- DROP-DOWN-MENU --> 
<div class="main">
    <article>
        <header>
            <h2 id="oben7">
                Test-Driven Development
            </h2>
            <hr>
        </header>
        
         <div class="authorInfoDi">
            <p>von <b><i>Gabriele Falace</i></b>
            <br />
            Computer-Ingenieur in Berlin</p>
         </div>
         <br />

        <section>
            <h3 id="einLeit">
                Einleitung
            </h3>
            <p>
                TDD ist eine Methodologie, die auf Testing konzentriert ist. Nach diese Methodologie, müssen der Business Code und seine Tests zusammen entwickelt werden.
                Nach diese Ansatz, ist es ein Anti-pattern um ein groß Modul ganz zu entwickeln und nur danach ausfinden, wie dieses Modul getestet werden soll.
                <br>
                Im Besonderen:
            <ul>
                <li>Man denkt nicht an Automatisierung von Tests (z.B. hat diese Methode einen einzige Zweck?)</li>
                <li>Man bekommt die Vorteile von Automatisierung nicht (z.B. Regressionstest während der Entwicklung)</li>
                <li>
                    Zeitsverwaltung im Project:
                    <ul>
                        <li>es wird immer wieder schweriger, das ganze Projekt zu testen</li>
                        <li>Wegen der Deadline (und auch aus dem Grund, dass Code auf jeden Fall "funktioniert") die Manager möchten keine Zeit am Ende für Teste verschwenden.</li>
                    </ul>
                </li>
                <li>Eine zu groß Arbeitsmenge am Ende des Projekts</li>
            </ul>
            </p>
            <p>
                Wichtige Vorteile sind:
            <ul>
                <li>gut Gleichgewicht von Testcode und Funktionalitätscode</li>
                <li>zuverlässige wiederholbarkeit von Tests (die wiederum leitet zu zuversichtlich Refaktorisierung)</li>
                <li>Design Prozess berücksichtigt Test up-front (d.h. Testable Design)</li>
            </ul>
            <img src="red_green.jpg" alt="Red-Green-refactor Diagram">
            Stichwörter:
            <ul>
                <li>xUnit Testing</li>
                <li>Class Under Test</li>
                <li>Method Under Test</li>
                <li>Test Fixture (Setup von Daten, die im Test verwendet werden)</li>
            </ul>
            Mythen (die falsch sind):
            <ul>
                <li>verdoppelte Coding-Effort</li>
                <li>
                    Alle Tests müssen bereits erledigt sein, vor die Funktionalitätscode geschrieben wird:
                    das ist einfach eine Fehlinterpretation von Test-First-Development! Man soll nur einfach den Red/Green/Refactor Zyklus folgen
                </li>
            </ul>
            Testing Frameworks (JVM Welt):
            <ul>
                <li>Mokckito: Mocking von Abhängigkeiten</li>
                <li>DBUnit: Fixtures von SQL Datenbanken</li>
                <li></li>
            </ul>
            H2 Datenbank:
            <ul>
                <li>relational Datenbank in Java</li>
                <li>in/out-of-process Ausführung (gut für Tests)</li>
                <li>das h2 Verzeichnis herunterladen und unzippen in /opt Ordner</li>
            </ul>
            </p>
        </section>

        <section>
            <h3 id="junit">
                JUnit
            </h3>
            <p>Ein gutes Test besteht aus vier Schritte:</p>
            <ul>
                <li>
                    Setup: <br> man baut hier Daten als Fixtures z.B. Objekte vorbereiten, die als Abhängigkeiten zum Class-Under-Test verbunden werden
                </li>
                <li>
                    Execution: <br> in diesem Schritt ruft man das Method-Under-Test auf.
                    Aufgepasst: je nach dem Komplexität vom Test, kann man <i>one-test-per-class</i> oder <i>one-test-per-method</i> bauen.
                </li>
                <li>
                    Verification: <br> die Ergebnisse von der Ausführung werden überprüft. Sehr wichtig nicht nur <i>Output</i> zu checken
                    sondern auch mögliche Änderungen im Zustand von Objekte.
                </li>
                <li>
                    Teardown: <br> Kram entfernen, unlocken und sauber machen, die war im Setup vorbereitet.
                </li>
            </ul>
            <p>Glücklicherweise gibt es in JUnit (Package <b style="font-family:monospace">org.junit</b>) eingebaute Unterstütung für jede Schritt.</p>
            <p>
                Jede Test wird mit der @Test Annotation markiert. Was wir wollen als Setup-Schritt ausführen, wird in eine Methode sein, die
                mit @Before markiert wird. Analog wird unsere Teardown-Methode mit @After markiert. Die genannte Mothoden werden vor und nach jede
                Test-Methode ausgeführt werden. Falls wir brauchen eine globale Setup/Teardown (d.h. die ist einmalig vor/nach <i>alle</i> dem Test gelaufen)
                stehen die @BeforeClass und @AfterClass Annotationen uns zu Verfügung.
            </p>
            <p>
                Beim Verification gibt es eine reiche Auswahl von <i>"Assertion"</i> Mechanismen:
                Nämlich gibt es die statische Methoden in <b style="font-family:monospace">org.junit.Assert.*</b> und die
                <b style="font-family:monospace">HamcrestMatcherAssert</b> Methoden.
            </p>
            <p>Hamcrest ist eine Bibliotheke, die das regelmäßige JUnit Assert-Mechanismus erweitert. Manchmal (eigentlich oft) sind die Assertions von
                Hamcrest lesbarer als die JUnit, manchmal aber umgekehrt.</p>
            Ein paar Beispiele:
            <pre>
                <code class="language-java">
                    // JUnit (here looking better)
                    assertEquals("Brown", actualCustomer.gatName());

                    // Hamcrest
                    assertThat(actualCustomer.gatName(), equalTo("Brown"));
                </code>
            </pre>
            <pre>
                <code class="language-java">
                    // JUnit
                    assertTrue(actualCustomer.gatName().startsWith("B");

                    // Hamcrest (here looking better)
                    assertThat(actualCustomer.gatName(), startsWith("B"));
                </code>
            </pre>
            Nun schauen wir uns ein Beispiel von eine Test-Methode:
            <pre>
                <code class="language-java">
                    // test name format test_operationName_expectedResult

                    @Test
                    public void test_transform_success() {
                        String orderNumberFixture = UUID.randomUUID().toString();
                        OrderSummary result = target.transform(null);
                        assertNotNull(result);
                        assertEquals(orderNumberFixture, result.getOrderNumber());
                    }
                </code>
            </pre>

            Eine Test-Methode kann mit <b style="font-family:monospace">@Ignore</b> markiert werden, damit der Test-Runner läuft sie nicht.

            Außerdem, können wir unsere Test-Methode sagen, dass sie sollte eine Exception erwarten
            <pre>
                <code class="language-java">
                    @Test(expected = IllegalArgumentException.class)
                    public void test_transform_failure() {
                        target.transform(null);
                    }
                </code>
            </pre>
        </section>

        <section>
            <h3 id="mock">
                Mockito
            </h3>
            <p>Häufig nutzen Objekte andere Objekte, d.h. Abhängigkeiten. Wie können wir unsere Tests "isoliert" machen?</p>
            <ul>
                <li>Shared Datenbank?</li>
                <li>Einfach warten, bis alle die andere Komponenten erledigt sind?</li>
            </ul>
            <p>Ein Mocking-Framework:</p>
            <ul>
                <li>bietet schon vorbereitet Mocking-Code</li>
                <li>nutzt der Proxy Entwurfsmuster</li>
                <li>beliebte: Mockito, EasyMock, JMock</li>
            </ul>
            Mockito unterstütz die drei Phasen:
            <ul>
                <li>Setup: Mocks bauen und Vehalten spezifizieren</li>
                <li>Execution: Mocks antworten zu MUT Aufrufen</li>
                <li>Verification: man kann überprüfen eigentliche Wechselwirkungen zwischen Mocks</li>
            </ul>
            Ein Code Beispiel:
            <pre>
                <code class="language-java">
                    OrderDao orderDaoMock = Mockito.mock(OrderDao.class);
                    Mockito.when(orderDaoMock.findById(id)).thenReturn(orderFixture);

                    // Ceate Class under test with mocked collaborator
                    OrderService service = new OrderService(orderDaoMock);

                    // Execution: nothing special to do.
                    // Invocation is real, but MUT will use the mocks
                    service.doSomething("id123");

                    Mockito.verify(orderDaoMock).findById("id123");
                </code>
            </pre>
            Eine vollständiger Beispiel:
            <pre>
                <code class="language-java">
                    @Test
                    public void test_getOrderSummary_success() {
                        //setup
                        orderService target = new OrderService();

                        //preparing fixtures
                        OrderEntity orderEntityFixture = new OrderEntity();
                        List&lt;OrderEntity&gt; listFixture = asList(orderEntityFixture);
                        OrderSummary orderSummaryFixture = new OrderSummary();

                        //inject mocks
                        OrderDao mockOrderDao = mock(OrderDao.class);
                        target.setOrderDao(mockOrderDao);
                        OrderTransformer mockOrderTrans = mock(OrderTransformer.class);

                        //stub interaction with mocks
                        when(mockOrderDao.findOrderByCustomerId(CUSTOMER_ID))
                            .thenReturn(listFixture);
                        when(mockOrderTrans.transform(orderEntityFixture))
                            .thenReturn(orderSummaryFixture);

                        //execution
                        List&lt;OrderSummary&gt; result = target.getOrderSummary(CUSTOMER_ID);

                        // verify results
                        assertNotNull(result);
                        assertEquals(1, result.size());
                        assertSame(orderSummaryFixture, result.get(0));

                        // verify interactions
                        verify(mockOrderDao).findOrdersByCustomer(CUSTOMER_ID);
                        verify(mockOrderTrans).transform(orderEntityFixture);
                    }
                </code>
            </pre>
            <p class="eng">
                creating mocks with Mockito.mock(...) create extra code though.
                We can use annotations and do initialization in the setup.
            </p>
            <pre>
                <code class="language-java">
                    @Mock OrderDao mockOrderDao;

                    @Before
                    public void setup(){
                        MockitoAnnotations.initMocks(this);
                    }
                </code>
            </pre>
            <p class="eng">
                If a given dependency implements multiple interfaces we use MockSettings.
            </p>
            <pre>
                <code class="language-java">
                    @Test
                    public void test_getOrderSummary() {
                        MockSettings settings = Mockito.withSettings();
                        OrderDao mockOrderDao = Mockito.mock(OrderDao.class, settings);
                    }
                </code>
            </pre>
            <div class="eng">
                Here Diagram: <br>
                OrderUtil extends both OrderFilter, OrderTransformer <br>
                OrderServiceImpl (class under test) uses OrderTransformer
            </div>
            <pre>
                <code class="language-java">
                    // Inside OrderServiceImpl

                    private OrderTransformer transformer;

                    ...

                    if(transformer instanceof OrderFilter) {
                        ((OrderFilter)transformer).filter(dataToFilter);
                    }
                </code>
            </pre>
            <p class="eng">
                in the corresponding test
            </p>
            <pre>
                <code class="language-java">
                    // In the test

                    MockSettings settings = Mockito.withSettings();
                    OrderTransformer mockTransform = Mockito.mock(OrderTransformer.class, settings.extraInterface(OrderFilter.class));

                    // also available:
                    settings.serializable();
                    settings.name("..."); // give a name to be logged when verification fails
                </code>
            </pre>
            <p class="eng">
                After we set up our mocks, we need to progam their interactions. It happens through the when/then pattern.
                Mockito.when() returns an OngoingStub&lt;T&gt; which offers the following: <br>
                - thenReturn(...) <br>
                - thenThrow(...) <br>
                - thenCallRealMethod(...) <br>
                - thenAnswer(...) <br>
                Let's see what do they offer us.
            </p>

            <p class="eng">
                thenReturn() - returns a specific object or value
            </p>
            <pre>
                <code class="language-java">
                    List&lt;OrderSummary&gt; listFixture = ...;
                    OngoingStub&lt;List&lt;OrderSummary&gt;&gt; invocationStub = when(mockOrderService.getOrderSummary(customerId));
                    invocationStub.thenReturn(listFixture);
                </code>
            </pre>

            <p class="eng">
                thenThrow() - returns a specific object or value
            </p>
            <pre>
                <code class="language-java">
                    when(obj.someMethod()).thenThrow(new MyException("msg"));
                    // Note that the exception must be supported by the "someMethod"

                    // for void methods can make sense:
                    Stubber stubber = Mockito.doThrow(new MyException("msg"));
                    stubber.when(mockService.processOrder(orderFixture));
                </code>
            </pre>

            <p class="eng">
                thenCallRealMethod() - uses the real instance
            </p>
            <pre>
                <code class="language-java">
                    Mockito.when(mockObj.targetMethod()).thenCallRealMethod();
                </code>
            </pre>

            <p class="eng">
                thenAnswer() - it's about argument matching
            </p>
            <pre>
                <code class="language-java">
                    when(mock.targetMethod(anyString()))
                        .thenAnswer(new Answer(){
                            Object answer(InvocationOnMock invocation){
                                // evaluate parameters to contro what is returned
                            }
                        });
                </code>
            </pre>
            <p class="eng">
                Mockito allows us to check our executions with Mockito.verify() <br>
                this method returns a proxy on which we can verify our calls.
            </p>
            <pre>
                <code class="language-java">
                    OrderService verificationProxy = Mockito.verify(mockOrderService);
                    verificationProxy.getOrderSummary(customerId);

                    // ... or

                    Mockito.verify(mockOrderService, Mockito.times(2))getOrderSummary(customerId);
                </code>
            </pre>
            <p class="eng">
                The Mockito class also provides us other "counting" tools for interactions: times(n), atLeastOnce(), atLeast(n), atMost(n), never().
                Thanks to these methods we can check if an interaction happened and how many times.
                It's also possible to verify global interactions, as in the following example:
            </p>
            <pre>
                <code class="language-java">
                    Mockito.verifyZeroInteractions(mockOne, mockTwo, ... );

                    // no more interactions after here
                    Mockito.verifyNoMoreInteractions(mockOne, mockTwo, ... );
                </code>
            </pre>
            <h4>Argument Matching</h4>
            <p class="eng"> What happens when we would pass in the MUT a value not mocked? </p>
            <pre><code class="language-java"> when(mockOrderDao.findById("23")).thenReturn(...); </code></pre>
            <p class="eng">
                How is the argument "23" matched? <br>
                The rule is: reference types <i>by equals()</i> value types by <i>==</i> <br>
                Explicit argument matching (i.e. with Matchers) gives more flexibility:
            </p>
            <pre>
                <code class="language-java">
                    List&lt;OrderEntity&gt; listFixure = ... ;

                    // more generic with anyString
                    when(mockOrderDao.findById(Matchers.anyString()))
                        .thenReturn(listFixture);
                </code>
            </pre>
            <p class="eng">
                <b>NOTICE</b> once a single argument is a Matcher instead of an actual value, then we need to use <b>only matchers</b>.
            </p>
            <pre>
                <code class="language-java">
                    // WRONG!!!
                    when(mockDao.findByStateAndRegion("DE", anyString())).thenReturn();

                    // Right
                    when(mockDao.findByStateAndRegion(Matchers.eq("DE"), anyString())).thenReturn();
                </code>
            </pre>
            <p>
                Hier eine Liste von häufige benutzt Matchers
            </p>
            <ul class="eng">
                <li>
                    Matchers.eq(...)
                </li>
                <li>
                    Matchers Any: anyInt(), anyDouble(), any(MyStuff.class), anySet(String.class).
                </li>
                <li>
                    String matchers: contains("substr"), endsWith("suffix"), startsWith("prefix"), match("^(Br|Cr)own")
                </li>
                <li>
                    Reference equality: same(ref), refEq(ref), refEq(ref, "excludeField")
                </li>
            </ul>

            <h4>Stubbing consecutive calls</h4>
            <p class="eng">
                When testing logic that needs to be resilient when error occurs (e.g. retry logic on errors or looping
                logic that either short-circuits or continues on exceptions <br>
                Example, business logic does some retrying:
            </p>
            <pre>
                <code class="language-java">
                    public String openNewOrder(long customerId) throws ServiceException {
                        // create an OrderEntity
                        boolean insertSuccessful = false;
                        int attempt = 1;
                        while(!insertSuccessful && attempt <= MAX_ATTEMPTS) {
                            try {
                                int resultValue = orderDato.insert(orderEntity);
                                if(resutValue==1)
                                    insertSuccessful = true;
                                else
                                    attempt++;
                            } catch(Exception e) {
                                attempt++;
                            }
                        }
                        if(!insertSuccessful)
                            throw new ServiceException("Data Error");
                        return orderEntity.getOrderNumber();
                    }
                </code>
            </pre>
            <p class="eng">Then in the tests: </p>
            <pre>
                <code class="language-java">
                    @Test
                    public void test_openNewOrder_successfullyRetries() throws Exception {

                        // mocking a sequence of 2 calls

                        when(orderDao.insert(any(OrderEntity.class)))
                            .thenThrow(new Exception("First attempt exception"))
                            .thenReturn(1);

                        target.openNewOrder(CUSTOMER_ID);
                        verify(orderDao, times(2)).insert(any(OrderEntity.class));
                    }

                    @Test(expected = ServiceException.class)
                    public void test_openNewOrder_failedDataInsert() throws Exception {
                        when(orderDao.insert(any(OrderEntity.class)))
                            .thenThrow(new Exception("First attempt exception"))
                            .thenThrow(new Exception("Second attempt exception"))

                        try {
                            target.openNewOrder(CUSTOMER_ID);
                        } finally {
                            verify(orderDao, times(2)).insert(any(OrderEntity.class));
                        }
                    }

                    // Also something like this is possible

                    InOrderVerifier inOrder = Mockito.inOrder(mockOrderService, mockTaxService);
                    inOrder.verify(mockOrderService).createOrder();
                    inOrder.verify(mockTaxService).calculateTax();
                </code>
            </pre>
            <h4>Argument Captors und Partial Mocks</h4>
            <p class="eng">
                Valiedating objects without direct access e.g. when the MUT creates an object and passes it
                to a dependency, but does not return it (thus it wouldn't be visible to the test). <br>
                Example: the openNewOrder method creates an OrderEntity and saves it through the DAO. The test
                never gets explicit access to that instance...
            </p>
            <pre>
                <code class="language-java">
                    ArgumentCaptor&lt;OrderEntity&gt; entityCaptor = ArgumentCaptor.forClass(OrderEntity.class);

                    // execute MUT

                    verify(orderDao).insert(entityCaptor.capture());
                    OrderEntity capturedEntity = entity.getValue();

                    // assertions on the captured value
                    assertNotNull(capturedEntity);
                </code>
            </pre>
            <p class="eng">
                Partial mocking: mock part of the behavior and rely on the implementation for the rest (mock any public/protected method).
            </p>

            Mocks:
            <ul class="eng">
                <li>Proxy-based instance routing calls to the mocking library</li>
                <li>When mocking a class, the proxy creates an instance of said class</li>
                <li>By default returns null, when no invocation stub is defined</li>
            </ul>

            Spy:
            <ul class="eng">
                <li>Proxies an existing object instance</li>
                <li>By default, when an invocation is not stubbed, it will call the real method!</li>
                <li>Invocation stubbing is needed to avoid actual call to the real method</li>
            </ul>
            <p class="eng">When spying, pay attention: initial call is routed to the real method, need accurate setup!</p>
            <pre>
                <code class="language-java">
                    List&lt;String&gt; liveList = new LinkedList&lt;&gt();
                    List&lt;String&gt; spyList = Mockito.spy(liveList);
                    //will result in IndexOutOfBoundException
                    when(spyList.get(0)).thenReturn("a result");
                </code>
            </pre>

            <p class="eng">Watch out: cannot mock final and/or private methods!</p>

        </section>


        <section>
            <h3 id="power">
                Powermock
            </h3>
            <p>
                Tool to be used in conjunction with Mockito for cases where Mockito is not enough. While Mockito uses
                a Proxy-based approach, PowerMock uses a custom classloader and manipulates bytecode.
            </p>
            <h4>Mocking static methods</h4>
            <pre>
                <code class="language-java">
                    // On the test class
                    @RunWith(PowerMockRunner.class)
                    @PrepareForTest(value = {WharehouseService.class})

                    // in the test method
                    PowerMockito.mockStatic(WharehouseService.class);
                    PowerMockito.when(WharehouseService.sendOrder(any(OrderMessage.class))
                        .thenReturn(true);

                    PowerMockito.verifyStatic();

                    ArgumentCaptor&lt;OrderMessage&gt; msgCaptor = ArgumentCaptor.forClass(OrderMessage.class);
                    WharehouseService.sendOrder(msgCaptor.capture());
                    OrderMessage capturedMsg = msgCaptor.getValue();
                    assertNotNull(capturedMsg);
                </code>
            </pre>

            <h4>Replacing object instantiation a.k.a. new XY()</h4>
            <p class="eng">
                PowerMockito.whenNew(…) <br>
                #1 zero-param constructor by class name (returns OngoingStub&lt;T&gt;) <br>
                #2 use reflection for specific constructor (returns WithOrWithoutExpectedArguments&lt;T&gt;) <br>
                #3 constructor by string value (returns ConstructorExpectationSetup&lt;T&gt;) <br>
                IMPORTANT! In this case we need to mention the class under test not the one being instantiated.
            </p>
            <pre>
                <code class="language-java">
                    @PrepareForTest(value = {ClassUnderTest.class})

                    Logger AUDIT_LOGGER = LoggerFactory.getLogger("Audit");

                    OrderCompletionAudit record = new OrderCompletionAudit();

                    // before execution of MUT

                    OrderCompletionAudit auditFixture = new OrderCompletionAudit();
                    PowerMockito.whenNew(OrderCompletionAudit.class)
                                .withNoArguments()
                                .thenReturn(auditFixture);
                </code>
            </pre>
            <p class="eng">Then we can do all the assertions we need on the auditFixture object</p>

            <h4>PowerMockito.mock(…)</h4>
            <p class="eng">
                like the one in regular Mockito, but also allows to mock final/private methods
            </p>
            <pre>
                <code class="language-java">
                    Method calculateDiscount = …

                    WithOrWithoutExpectedArguments args = when(mockedService, calculateDiscount);
                    args.withArguments(item1, order).thenReturn(discountedResult);

                    // to verify

                    PrivateMethodVerification ver = PowerMockito.verifyPrivate(mockService);

                    // use either this
                    ver.invoke(method).withArguments(item1, order);
                    //or this
                    ver.invoke("calculateDiscount", item1, order);

                </code>
            </pre>
        </section>

        <section>
            <h3 id="verWal">
                Verwaltung von Fixture und Testing von Datenkomponenten
            </h3>
            <p class="eng">
                Fixture state initialization for each test, so tests run independently. <br>
                Examples: <br>
                - instantiate objects to pass into methods <br>
                - declare mock stubs/initialize objects they return <br>
                - insert data in RDBMS for data access tests <br>
                - create files <br>
                Teardown everything not purged by JVM Garbage Collector: delete data from RDBMS and files.
            </p>
            <p class="eng">
                There are 4 core types of fixtures:
            </p>
            <ol>
                <li>Objects</li>
                <li>Mocks</li>
                <li>Persistent data</li>
                <li>Files</li>
            </ol>
            <h4>Objects</h4>
            <p class="eng">
                Can be verbose; find a balance between redundant setup and minimal field setup. <br>
                Consider a fixture FACTORY or a utility class (impact on readability?). <br>
                Create fresh instances per test: don't reuse instances across tests! Also teardown is per-test so
                a test should never undo the state (left dirty) of another!
            </p>
            <h4>Mocks</h4>
            <p class="eng">
                if an object is a member of the CUT then it's better if the related mock is a member of the test class.
                Otherwise it can be a local variable in the test method.
                IMPORTANT: Mocking in the @Before is not a good practice.
                The test becomes obscure and moreover would be the same for all tests. <br>
                Do not overinitialize Fixtures returned from stubbed calls!
            </p>
            <h4>Persistent data</h4>
            <p class="eng">
                Sometime one ends up using the same shared DB for maybe many projects. This leads to unpredictable
                test executions. <br>
                - tests that insert/manipulate data
                - "stealing" existing data is a bad idea: DB's are periodically cleaned/refreshed and data (and date ranges) may no longer match.
            </p>
            <p class="eng">
                Best practice: dedicated DB instance per developer with setup/teardown executed for each scenario. <br>
                Here we need to use a framework like DBUnit (see later).
            </p>

            <h4>Files</h4>
            <p class="eng">
                A good strategy is to: <br>
                1. Store a base template file
                2. if only-read operation, use the template
                3. if write operation, create a per-test copy and work on it
            </p>
            <p class="eng">JUnit provides a @Rule annotation and a TemporaryFolder class to facilitate file cleanup.</p>

            <h4>Data Access Testing</h4>
            <p class="eng">
                The preferredd way is to have a H2 in-memory which ensures data is gone after a test is done.
                In this way we also get a fresh state, even after abrupt termination in previous test.
            </p>
            <p class="eng">
                The setup of tables is required per-execution when running in-memory -> RunScript class from H2.
            </p>
            <h4>DBUnit</h4>
            <p class="eng">
                Three core abstractions <br>
                1. Database connection
                2. Data set management
                3. Database operations
            </p>
            <p class="eng">
                IDatabaseConnection <br>
                --- DatabaseConnection <br>
                --- DatabaseDatasourceConnection (JDBC pooled data source)
            </p>
            <p class="eng">
                IDataSet: many implementations (collection of tables stored in-memory in the JVM). <br>
                Possible sources: XML, Excel, CSV. <br>
                Database is programmatically created, we can combine multiple datasets into one. <br>
                There are 2 common scenarios:
            </p>
            <ul>
                <li>
                    data is stored in XML and prior to executing the test you load the data in the DB (READ OP)
                </li>
                <li>
                    a stored procedure takes a set of data, transforms it and then loads it into another table. <br>
                    Use 2 datasets when testing data transformations one as source, one as expected results.
                </li>
            </ul>
            <p class="eng">
                DatabaseOperation (abstract class) <br>
                Example: testing a DAO
            </p>
            <pre>
                <code class="language-java">
                    public class BaseDBUnitTestForDao {

                        protected static IDatabaseConnection CONN = null;

                        @BeforeClass
                        public static void setupClass(){
                            Properties dbProps = new Properties();
                            dbProps.put("user", DBInfo.USER);
                            dbProps.put("password", DBInfo.PASSWORD);

                            Connection jdbcConn = Driver.load().connect(DBInfo.URL, dbProps);

                            CONN = new DatabaseConnection(jdbcConn);

                            RunScript.execute(CONN.getConnection(), new FileReader("tabledef/site.ddl.sql"));

                            Map&lt;Object, Object&gt; props = new HashMap&lt;&gt;();
                            props.put();

                            EMF = Persistence.createEntityManagerFactory("orderPu", props);
                        }

                        @AfterClass
                        public static void teardownClass() throws Exception {
                            try {
                                if(EMF != null)
                                    if(EMF.isOpen())
                                        EMF.close();
                                    EMF = null;
                            }
                            finally {
                                if(EMF != null){
                                    CONN.close();
                                    CONN = null;
                                }
                            }
                        }

                        @Before
                        public void setup() throws Exception {
                            entityManager = EMF.createEntityManager();
                        }

                        @After
                        public void teardown() throws Exception {
                            if(entityManager != null){
                                if(entityManager.isOpen())
                                    entityManager.close();
                                entityManager = null;
                            }
                        }
                    }
                </code>
                <p>
                    Die DBInfo Klasse wird so aussehen:
                </p>
                <pre>
                    <code class="language-java">
                        public class DBInfo {
                            public final static String DRIVER = "org.h2.Driver";
                            public final static String URL = "jdbc:h2:mem:test" ;
                            public final static String USER = "sa";
                            public final static String PASSWORD = "";
                        }
                    </code>
                </pre>
            </pre>
            <p>
                Die eigentliche Test Klasse muss die BaseDBUnitTest Klasse erweitern.
            </p>
            <pre>
                <code class="language-java">
                    public class OrderDaoTest extends BaseDBUnitTest {

                        private OrderDaoImpl target = null;

                        private DefaultDataSet dataSet = null;

                        @Before
                        public void setup() throws Exception {
                            target = new OrderDaoJpaImpl();
                            target.setEntityManager(entityManager);
                            dataSet = new DefaultDataSet();          // proper order!
                            DefaultTable orderSourceTable = new DefaultTable("OrderSource", DBDataDef.ORDER_SOURCE_COLUMNS);
                            // a Column[] defined somewhere else

                            Object[][] orderSourceRows = createOrderSourceRows();
                            for(Object{} current : orderSourceRows)
                                orderSourceTable.addRow(current);
                            dataSet.addTable(orderSourceTable);
                            DatabaseOperation.INSERT.execute(CONN, dataSet);
                        }

                        @After
                        public void teardown() throws Exception {
                            DatabaseOperation.DELETE.execute(CONN, dataSet);
                        }

                        @Test
                        public void test_findByOrderSource() throws Exception {
                            List&lt;OrderEntity&gt; orderList = target.findByOrderSource("wo");
                            assertNotNull(orderList);
                            // etc ...
                        }

                        private Object[][] createOrderSourceRows(){
                            Object[][] orderSourceRows = new Object[][] {
                                new Object[] {
                                    1,
                                    "so",
                                    "Store Order",
                                    "cbrown",
                                    new DateTime().withYear(2012)
                                                    .withMonthOfYear(12)
                                                    .withDayOfMonth(31)
                                                    .toDate();
                                },
                                new Object[] {
                                    // similar as above ...
                                }
                            }
                            return orderSourceRows;
                        }
                    }
                </code>
            </pre>
            <p class="eng">
                The DatabaseOperation class offers lots of DB statements on datasets:
            </p>
            <ul class="eng">
                <li>INSERT - single inserts, based on the order tables were added to the DataSet</li>
                <li>UPDATE - fails if not each row already exists in the Dataset. Only specified columns are updated</li>
                <li>DELETE - deletes data specified in the data set matching the entries to rows in the table based on ID specified</li>
                <li>DELETE_ALL - delete all entries of a table </li>
                <li>TRUNCATE_TABLE - same as previous but uses truncate</li>
                <li>REFRESH - basically has the UPSERT "update or insert" semantics</li>
            </ul>
            <p>
                Es gibt noch CompositeOperation wie CLEAN_INSERT (erst DELETE und dann INSERT) und TransactionOperation, wo mehrere Operationen sind in einem Tansaktion gruppiert.
            </p>
            <p>
                File-based Datasets
            </p>
            <p>
                IDataSet
            </p>
            <ul>
                <li>getTable(tableName: String): ITable</li>
                <li>getTables(): ITable[]</li>
                <li>getTableNames(): String[]</li>
                <li>iterator : ITableIterator</li>
                <li>getTableMetadata(): ITableMetaData</li>
            </ul>
            <p>
                XML DataSets
            </p>
            <pre>
                <code class="language-xml">
                    &lt;dataset&gt;
                        &lt;table name="OrderSource"&gt;
                            &lt;coumn&gt;id&lt;/column&gt;
                            &lt;column&gt;code&lt;/column&gt;
                            &lt;row&gt;
                                &lt;value&gt;1&lt;/value&gt;
                                &lt;value&gt;so&lt;/value&gt;
                            &lt;/row&gt;
                        &lt;/table&gt;
                    &lt;/dataset&gt;
                </code>
            </pre>
            <p>
                Flat XML DataSets (falls eine Spalte vergessen wurde, Wert ist einfach null)
            </p>
            <pre>
                <code class="language-xml">
                    &lt;dataset&gt;
                        &lt;OrderSource id="1" code="so" /&gt;
                    &lt;/dataset&gt;
                </code>
            </pre>
            <p class="eng">
                There's a FlatXMLDataSetBuilder to create instances -> columnSensing field set to true will scan all elements of same name first.
                It slightly slows down... <br>
                The order the table is specified is very important! <br>
                [ORDER]  ---fk----> [ORDER_SOURCE]  THE REFERENCED TABLE MUST BE DECLARED FIRST
            </p>
            <p class="eng">
                Demo <br>
                we only modify the setup, test method stays the same <br>
                Folder: <br>
                 ./ src/test/resources
                 |---/ combigbox.b2csite.order.dao.impl
                    |__ orderDaoTest.xml
                    |__ orderDaoTest_flat.xml
            </p>
            <p>
                In die Test Klasse, man muss nur die zwei folgende ändern
            </p>
            <pre>
                <code class="language-java">
                    // first thing
                    IDataSet dataSet = null;
                    ...
                    @Before
                    public void setup() throws Exception {
                        target = new OrderDaoImpl();
                        target.setEntityManager(entityManager);
                        InputStream is = ClassLoader.getSystemResourceAsStream("path_to_file");
                        FlatXMLDataSetBuilder builder = new FlatXMLDataSetBuilder();
                        dataSet = builder.build();
                    }
                </code>
            </pre>

            <p>
                Composite Data Set - sie erlauben mehrfache Datasets durch eine
            </p>
            <pre>
                <code class="language-java">
                    IDataSet dataset1 = ...
                    IDataSet dataset2 = ...
                    IDataSet[] sourceDataSets = new IDataSet[]{dataset1, dataset2};
                    IDataSet compositeDataSet = new CompositeDataSet(sourceDataSets);
                </code>
            </pre>
            <p class="eng">
                Filter Data Set
            </p>
            <ul>
                <li>Store a lot of data in a single DataSet and narrow down when loaded (specify table to include/exclude)</li>
                <li>Re-sequence table in the dataset (i.e. change the loading ordering)</li>
            </ul>
            <p class="eng">
                Replacement Data Set
            </p>
            <ul>
                <li>
                    wraps an IDataSet and allows replacing value <br>
                    IDataSet replaceDataSet = new ReplacementDataSet(aDataSet); <br>
                    replaceDataSet.addReplacementSubstring("x-null-x", null);
                </li>
            </ul>
            <p class="eng">
                Datasets created from other Datasets
            </p>
            <ol>
                <li>
                    DatabaseDataSet (all the database & tables data is loaded lazily)
                </li>
                <li>
                    QueryDataSet
                    <ol>
                        <li>upfront definition of accessed tables</li>
                        <li>limit tables, rows (via criteria) and columns fetched</li>
                        <li>create logical tables based on results of a complex query</li>
                    </ol>
                </li>
                <pre>
                    <code class="language-java">
                        IDataSet expectedDataSet = ... // load from file
                        IDataSet actualDataSet = new QueryDataSet();
                        // add tables that you want to verify in the query dataset
                        Assertion.assertEquals(expectedDataSet, actualDataSet);
                    </code>
                </pre>
            </ol>
        </section>
    </article>
</div>


<div class="footer">
</div>
</body>
</html>
